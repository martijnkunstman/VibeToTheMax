<!DOCTYPE html>
<html>
<head>
    <title>AI Evolution - High-Res Sensors</title>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: 'Courier New', monospace; display: flex; overflow: hidden; }
        #sidebar { width: 320px; padding: 20px; border-right: 2px solid #0f0; background: #080808; z-index: 10; height: 100vh; }
        canvas { background: #000; flex-grow: 1; }
        .stat { margin-bottom: 8px; font-size: 13px; border-left: 2px solid #0f0; padding-left: 10px; color: #fff; }
        .label { color: #0f0; font-weight: bold; margin-top: 15px; display: block; font-size: 10px; text-transform: uppercase; }
        #miniMap { background: #000; border: 1px solid #333; margin-top: 5px; }
        #nnCanvas { background: #050505; border: 1px solid #222; margin-top: 5px; }
        button { background: #0f0; color: #000; border: none; padding: 10px; cursor: pointer; width: 100%; margin-top: 20px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>OS_SENSORY_UPGRADE</h2>
        <div class="stat">GEN: <span id="gen">1</span></div>
        <div class="stat">ELITE FITNESS: <span id="fitness">0</span></div>
        <div class="stat">ALIVE: <span id="aliveCount">0</span></div>
        
        <span class="label">Radar (4000x4000)</span>
        <canvas id="miniMap" width="280" height="200"></canvas>
        
        <span class="label">Brain (11 In | 8 Hidden)</span>
        <canvas id="nnCanvas" width="280" height="200"></canvas>
        
        <button onclick="resetEvolution()">Hard Format</button>
    </div>
    <canvas id="simCanvas"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const mmCtx = document.getElementById('miniMap').getContext('2d');
const nnCtx = document.getElementById('nnCanvas').getContext('2d');

const WORLD_SIZE = 4000;
const STORAGE_KEY = 'ai_v6_wide_sensors';
const SENSOR_COUNT = 11;
const SENSOR_RANGE = 350;
const DETECTION_RADIUS = 80; // Wider detection radius

canvas.width = window.innerWidth - 320;
canvas.height = window.innerHeight;

class NeuralNetwork {
    constructor(inputs, hidden, outputs) {
        this.weights1 = Array.from({length: hidden}, () => Array(inputs).fill(0).map(() => Math.random() * 2 - 1));
        this.weights2 = Array.from({length: outputs}, () => Array(hidden).fill(0).map(() => Math.random() * 2 - 1));
        this.lastInputs = Array(inputs).fill(0);
        this.lastHidden = Array(hidden).fill(0);
        this.lastOutputs = Array(outputs).fill(0);
    }
    predict(inputs) {
        this.lastInputs = inputs;
        this.lastHidden = this.weights1.map(row => 1 / (1 + Math.exp(-row.reduce((sum, w, i) => sum + w * inputs[i], 0))));
        this.lastOutputs = this.weights2.map(row => 1 / (1 + Math.exp(-row.reduce((sum, w, i) => sum + w * this.lastHidden[i], 0))));
        return this.lastOutputs;
    }
    mutate(rate) {
        const m = (v) => Math.random() < rate ? v + (Math.random() * 0.4 - 0.2) : v;
        this.weights1 = this.weights1.map(row => row.map(m));
        this.weights2 = this.weights2.map(row => row.map(m));
    }
}

class Vehicle {
    constructor(brain = null) {
        this.brain = brain || new NeuralNetwork(SENSOR_COUNT, 8, 2);
        this.spawn();
    }
    spawn() {
        this.x = Math.random() * WORLD_SIZE;
        this.y = Math.random() * WORLD_SIZE;
        this.angle = Math.random() * Math.PI * 2;
        this.health = 100;
        this.fitness = 0;
        this.dead = false;
        this.sensorValues = Array(SENSOR_COUNT).fill(0);
    }
    update(food, obstacles) {
        if (this.dead) return;

        if (this.x < 0) this.x = WORLD_SIZE; else if (this.x > WORLD_SIZE) this.x = 0;
        if (this.y < 0) this.y = WORLD_SIZE; else if (this.y > WORLD_SIZE) this.y = 0;

        // Enhanced Sensory Array Logic
        for (let i = 0; i < SENSOR_COUNT; i++) {
            const angleOffset = -1.0 + (i / (SENSOR_COUNT - 1)) * 2.0; // Spread rays
            const rayAngle = this.angle + angleOffset;
            let val = 0;
            
            const scanX = this.x + Math.cos(rayAngle) * SENSOR_RANGE;
            const scanY = this.y + Math.sin(rayAngle) * SENSOR_RANGE;

            food.forEach(f => { if(Math.hypot(f.x - scanX, f.y - scanY) < DETECTION_RADIUS) val = 1; });
            obstacles.forEach(o => { if(Math.hypot(o.x - scanX, o.y - scanY) < DETECTION_RADIUS) val = -1; });
            this.sensorValues[i] = val;
        }

        const [l, r] = this.brain.predict(this.sensorValues);
        this.angle += (l - r) * 0.12;
        this.x += Math.cos(this.angle) * (l + r) * 3.5;
        this.y += Math.sin(this.angle) * (l + r) * 3.5;

        this.health -= 0.15;
        this.fitness += 0.1;

        food.forEach((f, i) => {
            if (Math.hypot(this.x-f.x, this.y-f.y) < 20) {
                this.health += 50; this.fitness += 200;
                food[i] = {x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE};
            }
        });
        obstacles.forEach(o => { if (Math.hypot(this.x-o.x, this.y-o.y) < 18) this.dead = true; });
        if (this.health <= 0) this.dead = true;
    }
    draw(ctx, isLeader) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Visualize Long Sensors
        for (let i = 0; i < SENSOR_COUNT; i++) {
            const angleOffset = -1.0 + (i / (SENSOR_COUNT - 1)) * 2.0;
            const v = this.sensorValues[i];
            ctx.strokeStyle = v > 0 ? '#0f0' : (v < 0 ? '#f00' : 'rgba(255,255,255,0.05)');
            ctx.lineWidth = v !== 0 ? 2 : 1;
            ctx.beginPath(); 
            ctx.moveTo(0,0); 
            ctx.lineTo(Math.cos(angleOffset) * SENSOR_RANGE, Math.sin(angleOffset) * SENSOR_RANGE); 
            ctx.stroke();
        }

        ctx.fillStyle = isLeader ? '#fff' : '#0ff';
        ctx.beginPath(); ctx.moveTo(18,0); ctx.lineTo(-10,-10); ctx.lineTo(-10,10); ctx.fill();
        ctx.restore();
    }
}

let vehicles = [], food = [], obstacles = [], gen = 1;
let cameraX = 0, cameraY = 0;

function init() {
    const data = localStorage.getItem(STORAGE_KEY);
    let saved = data ? JSON.parse(data) : null;
    food = Array.from({length: 150}, () => ({x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE}));
    obstacles = Array.from({length: 100}, () => ({x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE}));
    vehicles = Array.from({length: 12}, (_, i) => {
        const b = new NeuralNetwork(SENSOR_COUNT, 8, 2);
        if (saved) {
            b.weights1 = saved.w1; b.weights2 = saved.w2;
            if (i > 0) b.mutate(0.12);
        }
        return new Vehicle(b);
    });
}

function drawUI(leader) {
    mmCtx.fillStyle = '#000'; mmCtx.fillRect(0,0,280,200);
    const s = 280/WORLD_SIZE;
    food.forEach(f => { mmCtx.fillStyle = '#0a0'; mmCtx.fillRect(f.x*s, f.y*s, 1.5, 1.5); });
    obstacles.forEach(o => { mmCtx.fillStyle = '#a00'; mmCtx.fillRect(o.x*s, o.y*s, 1.5, 1.5); });
    vehicles.forEach(v => { if(!v.dead) { mmCtx.fillStyle = (v===leader)?'#fff':'#0ff'; mmCtx.fillRect(v.x*s, v.y*s, 3, 3); }});

    nnCtx.clearRect(0,0,280,200);
    leader.brain.lastInputs.forEach((v, i) => {
        nnCtx.fillStyle = v > 0 ? '#0f0' : (v < 0 ? '#f00' : '#222');
        nnCtx.beginPath(); nnCtx.arc(30, 15+i*16.5, 6, 0, 7); nnCtx.fill();
    });
}

function loop() {
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width, canvas.height);
    let alive = vehicles.filter(v => !v.dead);
    let leader = alive[0] || vehicles[0];

    cameraX += (leader.x - canvas.width/2 - cameraX) * 0.05;
    cameraY += (leader.y - canvas.height/2 - cameraY) * 0.05;

    ctx.save(); ctx.translate(-cameraX, -cameraY);
    food.forEach(f => { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(f.x, f.y, 8, 0, 7); ctx.fill(); });
    obstacles.forEach(o => { ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(o.x, o.y, 10, 0, 7); ctx.fill(); });
    alive.forEach(v => { v.update(food, obstacles); v.draw(ctx, v === leader); });
    ctx.restore();

    drawUI(leader);
    document.getElementById('aliveCount').innerText = alive.length;

    if (alive.length === 0) {
        let best = vehicles.sort((a,b) => b.fitness - a.fitness)[0];
        localStorage.setItem(STORAGE_KEY, JSON.stringify({w1: best.brain.weights1, w2: best.brain.weights2}));
        gen++; document.getElementById('gen').innerText = gen;
        document.getElementById('fitness').innerText = Math.round(best.fitness);
        init();
    }
    requestAnimationFrame(loop);
}

function resetEvolution() { localStorage.removeItem(STORAGE_KEY); location.reload(); }
init();
loop();
</script>
</body>
</html>