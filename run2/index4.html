<!DOCTYPE html>
<html>
<head>
    <title>AI Evolution - Massive World</title>
    <style>
        body { margin: 0; background: #050505; color: #0f0; font-family: 'Courier New', monospace; display: flex; overflow: hidden; }
        #sidebar { width: 300px; padding: 20px; border-right: 1px solid #0f0; background: #000; z-index: 10; height: 100vh; overflow-y: auto; }
        canvas { background: #000; flex-grow: 1; }
        .stat { margin-bottom: 8px; font-size: 12px; border-left: 2px solid #0f0; padding-left: 8px; }
        .mini-map { border: 1px solid #444; background: #111; margin-top: 10px; }
        button { background: #0f0; color: #000; border: none; padding: 8px; cursor: pointer; width: 100%; margin-top: 10px; font-weight: bold; }
        h2 { font-size: 1.1em; letter-spacing: 1px; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>CORE_SYSTEM_V3</h2>
        <div class="stat">GEN: <span id="gen">1</span></div>
        <div class="stat">ELITE FITNESS: <span id="fitness">0</span></div>
        <div class="stat">ALIVE: <span id="aliveCount">10</span></div>
        <div class="stat">WORLD SIZE: 4000x4000</div>
        
        <canvas id="nnCanvas" width="260" height="160"></canvas>
        
        <div class="stat">GLOBAL RADAR (MAP)</div>
        <canvas id="miniMap" class="mini-map" width="260" height="200"></canvas>
        
        <button onclick="resetEvolution()">Hard Restart</button>
        <div id="memory-status" style="font-size:10px; color:#666; margin-top:5px;"></div>
    </div>
    <canvas id="simCanvas"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const mmCanvas = document.getElementById('miniMap');
const mmCtx = mmCanvas.getContext('2d');
const nnCtx = document.getElementById('nnCanvas').getContext('2d');

// --- Configuration ---
const WORLD_SIZE = 4000;
const STORAGE_KEY = 'ai_v3_massive';
canvas.width = window.innerWidth - 300;
canvas.height = window.innerHeight;

// --- Neural Network (Same Robust Logic) ---
class NeuralNetwork {
    constructor(inputs, hidden, outputs) {
        this.weights1 = Array.from({length: hidden}, () => Array(inputs).fill(0).map(() => Math.random() * 2 - 1));
        this.weights2 = Array.from({length: outputs}, () => Array(hidden).fill(0).map(() => Math.random() * 2 - 1));
        this.lastInputs = [0,0,0,0,0];
        this.lastHidden = Array(hidden).fill(0);
    }
    predict(inputs) {
        this.lastInputs = inputs;
        this.lastHidden = this.weights1.map(row => 1 / (1 + Math.exp(-row.reduce((sum, w, i) => sum + w * inputs[i], 0))));
        return this.weights2.map(row => 1 / (1 + Math.exp(-row.reduce((sum, w, i) => sum + w * this.lastHidden[i], 0))));
    }
    mutate(rate) {
        const m = (v) => Math.random() < rate ? v + (Math.random() * 0.4 - 0.2) : v;
        this.weights1 = this.weights1.map(row => row.map(m));
        this.weights2 = this.weights2.map(row => row.map(m));
    }
}

// --- Vehicle with World Wrap Logic ---
class Vehicle {
    constructor(brain = null) {
        this.brain = brain || new NeuralNetwork(5, 6, 2);
        this.spawn();
    }
    spawn() {
        this.x = Math.random() * WORLD_SIZE;
        this.y = Math.random() * WORLD_SIZE;
        this.angle = Math.random() * Math.PI * 2;
        this.health = 100;
        this.fitness = 0;
        this.dead = false;
        this.sensors = [0,0,0,0,0];
    }
    update() {
        if (this.dead) return;

        // Wrap Around Logic
        if (this.x < 0) this.x = WORLD_SIZE;
        if (this.x > WORLD_SIZE) this.x = 0;
        if (this.y < 0) this.y = WORLD_SIZE;
        if (this.y > WORLD_SIZE) this.y = 0;

        const sensorAngles = [-0.5, -0.25, 0, 0.25, 0.5];
        this.sensors = sensorAngles.map(off => {
            let reading = 0;
            const lx = this.x + Math.cos(this.angle + off) * 120;
            const ly = this.y + Math.sin(this.angle + off) * 120;
            food.forEach(f => { if(Math.hypot(f.x-lx, f.y-ly) < 40) reading = 1; });
            obstacles.forEach(o => { if(Math.hypot(o.x-lx, o.y-ly) < 40) reading = -1; });
            return reading;
        });

        const [l, r] = this.brain.predict(this.sensors);
        this.angle += (l - r) * 0.15;
        this.x += Math.cos(this.angle) * (l + r) * 4;
        this.y += Math.sin(this.angle) * (l + r) * 4;

        this.health -= 0.12;
        this.fitness += 0.1;

        food.forEach((f, i) => {
            if (Math.hypot(this.x-f.x, this.y-f.y) < 20) {
                this.health += 60; this.fitness += 200;
                food[i] = {x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE};
            }
        });

        obstacles.forEach(o => {
            if (Math.hypot(this.x-o.x, this.y-o.y) < 18) this.die();
        });

        if (this.health <= 0) this.die();
    }
    die() { this.dead = true; }
}

// --- Sim Logic ---
let vehicles = [];
let food = Array.from({length: 100}, () => ({x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE}));
let obstacles = Array.from({length: 80}, () => ({x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE}));
let gen = 1;
let cameraX = 0, cameraY = 0;

function init() {
    const data = localStorage.getItem(STORAGE_KEY);
    let saved = data ? JSON.parse(data) : null;
    vehicles = Array.from({length: 15}, (_, i) => {
        const b = new NeuralNetwork(5, 6, 2);
        if (saved) {
            b.weights1 = saved.w1; b.weights2 = saved.w2;
            if (i > 0) b.mutate(0.1);
        }
        return new Vehicle(b);
    });
}

function loop() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width, canvas.height);

    let alive = vehicles.filter(v => !v.dead);
    let target = alive[0] || vehicles[0];
    
    // Smooth Camera Follow
    cameraX += (target.x - canvas.width/2 - cameraX) * 0.1;
    cameraY += (target.y - canvas.height/2 - cameraY) * 0.1;

    ctx.save();
    ctx.translate(-cameraX, -cameraY);

    // Draw Grid
    ctx.strokeStyle = '#111';
    for(let i=0; i<=WORLD_SIZE; i+=200) {
        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, WORLD_SIZE); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(WORLD_SIZE, i); ctx.stroke();
    }

    food.forEach(f => { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(f.x, f.y, 8, 0, 7); ctx.fill(); });
    obstacles.forEach(o => { ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(o.x, o.y, 10, 0, 7); ctx.fill(); });
    
    alive.forEach(v => {
        v.update();
        ctx.save();
        ctx.translate(v.x, v.y); ctx.rotate(v.angle);
        ctx.fillStyle = '#0ff';
        ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(-10,-10); ctx.lineTo(-10,10); ctx.fill();
        ctx.restore();
    });
    ctx.restore();

    // UI & MiniMap
    drawMiniMap();
    document.getElementById('aliveCount').innerText = alive.length;

    if (alive.length === 0) {
        let best = vehicles.sort((a,b) => b.fitness - a.fitness)[0];
        localStorage.setItem(STORAGE_KEY, JSON.stringify({w1: best.brain.weights1, w2: best.brain.weights2}));
        gen++;
        document.getElementById('gen').innerText = gen;
        document.getElementById('fitness').innerText = Math.round(best.fitness);
        init();
    }
    requestAnimationFrame(loop);
}

function drawMiniMap() {
    mmCtx.fillStyle = '#000'; mmCtx.fillRect(0,0,260,200);
    const s = 260/WORLD_SIZE;
    food.forEach(f => { mmCtx.fillStyle = '#0f0'; mmCtx.fillRect(f.x*s, f.y*s, 2, 2); });
    obstacles.forEach(o => { mmCtx.fillStyle = '#f00'; mmCtx.fillRect(o.x*s, o.y*s, 2, 2); });
    vehicles.forEach(v => { if(!v.dead) { mmCtx.fillStyle = '#fff'; mmCtx.fillRect(v.x*s, v.y*s, 4, 4); }});
}

function resetEvolution() { localStorage.removeItem(STORAGE_KEY); location.reload(); }

init();
loop();
</script>
</body>
</html>