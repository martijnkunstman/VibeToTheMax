<!DOCTYPE html>
<html>
<head>
    <title>AI Thruster - Neural Visualization</title>
    <style>
        body { margin: 0; background: #050505; color: #0f0; font-family: 'Courier New', monospace; display: flex; overflow: hidden; }
        #sidebar { width: 320px; padding: 20px; border-right: 2px solid #0f0; background: #000; z-index: 10; height: 100vh; }
        canvas { background: #000; flex-grow: 1; }
        .stat { margin-bottom: 8px; font-size: 12px; border-left: 2px solid #0f0; padding-left: 8px; color: #fff; }
        .label { color: #0f0; font-weight: bold; margin-top: 15px; display: block; font-size: 10px; }
        button { background: #0f0; color: #000; border: none; padding: 8px; cursor: pointer; width: 100%; margin-top: 20px; font-weight: bold; }
        #nnCanvas { background: #080808; border: 1px solid #222; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>NEURAL_ENGINE_V4</h2>
        <div class="stat">GEN: <span id="gen">1</span></div>
        <div class="stat">ELITE FITNESS: <span id="fitness">0</span></div>
        
        <span class="label">LIVE BRAIN (BEST VEHICLE)</span>
        <canvas id="nnCanvas" width="280" height="240"></canvas>
        
        <span class="label">WORLD RADAR</span>
        <canvas id="miniMap" width="280" height="180" style="border:1px solid #222;"></canvas>
        
        <button onclick="resetEvolution()">Factory Reset</button>
    </div>
    <canvas id="simCanvas"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const nnCanvas = document.getElementById('nnCanvas');
const nnCtx = nnCanvas.getContext('2d');
const mmCtx = document.getElementById('miniMap').getContext('2d');

const WORLD_SIZE = 4000;
const STORAGE_KEY = 'ai_v4_visual';
canvas.width = window.innerWidth - 320;
canvas.height = window.innerHeight;

class NeuralNetwork {
    constructor(inputs, hidden, outputs) {
        this.weights1 = Array.from({length: hidden}, () => Array(inputs).fill(0).map(() => Math.random() * 2 - 1));
        this.weights2 = Array.from({length: outputs}, () => Array(hidden).fill(0).map(() => Math.random() * 2 - 1));
        this.lastInputs = Array(inputs).fill(0);
        this.lastHidden = Array(hidden).fill(0);
        this.lastOutputs = Array(outputs).fill(0);
    }
    predict(inputs) {
        this.lastInputs = inputs;
        this.lastHidden = this.weights1.map(row => 1 / (1 + Math.exp(-row.reduce((sum, w, i) => sum + w * inputs[i], 0))));
        this.lastOutputs = this.weights2.map(row => 1 / (1 + Math.exp(-row.reduce((sum, w, i) => sum + w * this.lastHidden[i], 0))));
        return this.lastOutputs;
    }
    mutate(rate) {
        const m = (v) => Math.random() < rate ? v + (Math.random() * 0.4 - 0.2) : v;
        this.weights1 = this.weights1.map(row => row.map(m));
        this.weights2 = this.weights2.map(row => row.map(m));
    }
}

class Vehicle {
    constructor(brain = null) {
        this.brain = brain || new NeuralNetwork(5, 6, 2);
        this.spawn();
        this.thrustL = 0;
        this.thrustR = 0;
    }
    spawn() {
        this.x = Math.random() * WORLD_SIZE;
        this.y = Math.random() * WORLD_SIZE;
        this.angle = Math.random() * Math.PI * 2;
        this.health = 100;
        this.fitness = 0;
        this.dead = false;
    }
    update(food, obstacles) {
        if (this.dead) return;

        // Wrap world
        if (this.x < 0) this.x = WORLD_SIZE; else if (this.x > WORLD_SIZE) this.x = 0;
        if (this.y < 0) this.y = WORLD_SIZE; else if (this.y > WORLD_SIZE) this.y = 0;

        // Sensors
        const sensorAngles = [-0.6, -0.3, 0, 0.3, 0.6];
        const sensorData = sensorAngles.map(off => {
            let val = 0;
            const lx = this.x + Math.cos(this.angle + off) * 100;
            const ly = this.y + Math.sin(this.angle + off) * 100;
            food.forEach(f => { if(Math.hypot(f.x-lx, f.y-ly) < 40) val = 1; });
            obstacles.forEach(o => { if(Math.hypot(o.x-lx, o.y-ly) < 40) val = -1; });
            return val;
        });

        const [l, r] = this.brain.predict(sensorData);
        this.thrustL = l;
        this.thrustR = r;

        this.angle += (l - r) * 0.12;
        this.x += Math.cos(this.angle) * (l + r) * 3.5;
        this.y += Math.sin(this.angle) * (l + r) * 3.5;

        this.health -= 0.15;
        this.fitness += 0.1;

        // Collisions
        food.forEach((f, i) => {
            if (Math.hypot(this.x-f.x, this.y-f.y) < 15) {
                this.health += 50; this.fitness += 150;
                food[i] = {x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE};
            }
        });
        obstacles.forEach(o => { if (Math.hypot(this.x-o.x, this.y-o.y) < 15) this.dead = true; });
        if (this.health <= 0) this.dead = true;
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Visual Thrusters (Exhaust Flames)
        if (this.thrustL > 0.1) {
            ctx.fillStyle = `rgba(255, 100, 0, ${this.thrustL})`;
            ctx.fillRect(-15, -10, -this.thrustL * 20, 4);
        }
        if (this.thrustR > 0.1) {
            ctx.fillStyle = `rgba(255, 100, 0, ${this.thrustR})`;
            ctx.fillRect(-15, 6, -this.thrustR * 20, 4);
        }

        // Vehicle Body
        ctx.fillStyle = '#0ff';
        ctx.beginPath(); ctx.moveTo(12,0); ctx.lineTo(-8,-8); ctx.lineTo(-8,8); ctx.fill();
        ctx.restore();
    }
}

let vehicles = [], food = [], obstacles = [], gen = 1;
let cameraX = 0, cameraY = 0;

function init() {
    const data = localStorage.getItem(STORAGE_KEY);
    let saved = data ? JSON.parse(data) : null;
    food = Array.from({length: 100}, () => ({x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE}));
    obstacles = Array.from({length: 70}, () => ({x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE}));
    vehicles = Array.from({length: 12}, (_, i) => {
        const b = new NeuralNetwork(5, 6, 2);
        if (saved) {
            b.weights1 = saved.w1; b.weights2 = saved.w2;
            if (i > 0) b.mutate(0.12);
        }
        return new Vehicle(b);
    });
}

function visualizeBrain(brain) {
    nnCtx.clearRect(0,0,280,240);
    const iX = 40, hX = 140, oX = 240;
    
    // Draw Weights
    brain.weights1.forEach((row, hIdx) => {
        row.forEach((w, iIdx) => {
            nnCtx.strokeStyle = w > 0 ? `rgba(0,255,0,${Math.abs(w)})` : `rgba(255,0,0,${Math.abs(w)})`;
            nnCtx.lineWidth = Math.abs(w) * 2;
            nnCtx.beginPath(); nnCtx.moveTo(iX, 40+iIdx*40); nnCtx.lineTo(hX, 20+hIdx*40); nnCtx.stroke();
        });
    });
    brain.weights2.forEach((row, oIdx) => {
        row.forEach((w, hIdx) => {
            nnCtx.strokeStyle = w > 0 ? `rgba(0,255,0,${Math.abs(w)})` : `rgba(255,0,0,${Math.abs(w)})`;
            nnCtx.lineWidth = Math.abs(w) * 2;
            nnCtx.beginPath(); nnCtx.moveTo(hX, 20+hIdx*40); nnCtx.lineTo(oX, 80+oIdx*80); nnCtx.stroke();
        });
    });

    // Draw Neurons
    const drawN = (x, y, val) => {
        nnCtx.fillStyle = val > 0.5 ? '#0f0' : (val < -0.5 ? '#f00' : '#222');
        nnCtx.beginPath(); nnCtx.arc(x, y, 10, 0, 7); nnCtx.fill();
        nnCtx.strokeStyle = '#fff'; nnCtx.lineWidth = 1; nnCtx.stroke();
    };
    brain.lastInputs.forEach((v, i) => drawN(iX, 40+i*40, v));
    brain.lastHidden.forEach((v, i) => drawN(hX, 20+i*40, v));
    brain.lastOutputs.forEach((v, i) => drawN(oX, 80+i*80, v));
}

function loop() {
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width, canvas.height);
    let alive = vehicles.filter(v => !v.dead);
    let leader = alive[0] || vehicles[0];

    cameraX += (leader.x - canvas.width/2 - cameraX) * 0.05;
    cameraY += (leader.y - canvas.height/2 - cameraY) * 0.05;

    ctx.save(); ctx.translate(-cameraX, -cameraY);
    food.forEach(f => { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(f.x, f.y, 6, 0, 7); ctx.fill(); });
    obstacles.forEach(o => { ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(o.x, o.y, 10, 0, 7); ctx.fill(); });
    alive.forEach(v => { v.update(food, obstacles); v.draw(ctx); });
    ctx.restore();

    if (alive.length > 0) visualizeBrain(leader.brain);

    if (alive.length === 0) {
        let best = vehicles.sort((a,b) => b.fitness - a.fitness)[0];
        localStorage.setItem(STORAGE_KEY, JSON.stringify({w1: best.brain.weights1, w2: best.brain.weights2}));
        gen++; document.getElementById('gen').innerText = gen;
        document.getElementById('fitness').innerText = Math.round(best.fitness);
        init();
    }
    requestAnimationFrame(loop);
}

function resetEvolution() { localStorage.removeItem(STORAGE_KEY); location.reload(); }
init();
loop();
</script>
</body>
</html>