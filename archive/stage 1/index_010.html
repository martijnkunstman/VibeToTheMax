<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Rapier2D - AI Explorer</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; font-family: 'Courier New', Courier, monospace; }
  canvas { display: block; }
  #hud {
    position: absolute; top: 20px; left: 20px; color: #00FF00;
    font-size: 24px; pointer-events: none; text-shadow: 2px 2px 4px #000;
  }
  /* Moves Tweakpane to the bottom so it doesn't overlap the Mini-map */
  .tp-dfwv { bottom: 20px !important; top: auto !important; }
</style>
</head>
<body>
<div id="hud">SCORE: 0 | STATUS: MANUAL</div>
<canvas id="game"></canvas>

<script type="module">
import RAPIER from "https://cdn.skypack.dev/@dimforge/rapier2d-compat";
import { Pane } from "https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js";

/* ---------------- INIT ---------------- */

await RAPIER.init();

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const hud = document.getElementById("hud");

let score = 0;
let trail = [];
let targetFood = null;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

const SCALE = 60; 
const SIZE = 1;   

/* ---------------- PARAMETERS ---------------- */

const params = {
  thrustPower: 0.2,
  turnThrustMult: 0.5,
  worldWidth: 80,
  worldHeight: 80,
  foodCount: 60,
  zoom: 0.8,
  showMiniMap: true,
  // AI Params
  autoSteer: false,
  autoThrust: false,
  sensorRange: 25,
  steeringStrength: 0.12,
  // Visuals
  showVelocity: true,
  showThrusters: true,
  showTrail: true,
  trailLength: 100
};

/* ---------------- TWEAKPANE ---------------- */

const pane = new Pane();
const worldPane = pane.addFolder({ title: "World" });
worldPane.addBinding(params, "worldWidth", { min: 20, max: 300 });
worldPane.addBinding(params, "worldHeight", { min: 20, max: 300 });
worldPane.addBinding(params, "zoom", { min: 0.1, max: 2.0 });

const aiPane = pane.addFolder({ title: "AI Pilot" });
aiPane.addBinding(params, "autoSteer", { label: "Auto-Steer" });
aiPane.addBinding(params, "autoThrust", { label: "Auto-Thrust" });
aiPane.addBinding(params, "sensorRange", { min: 5, max: 100 });
aiPane.addBinding(params, "steeringStrength", { min: 0.01, max: 0.5 });

const visualPane = pane.addFolder({ title: "Visuals" });
visualPane.addBinding(params, "showVelocity");
visualPane.addBinding(params, "showThrusters");
visualPane.addBinding(params, "showTrail");

/* ---------------- PHYSICS WORLD ---------------- */

const world = new RAPIER.World({ x: 0, y: 0 });

const vehicle = world.createRigidBody(
  RAPIER.RigidBodyDesc.dynamic()
    .setTranslation(0, 0)
    .setLinearDamping(1.2)
    .setAngularDamping(2.5)
);
world.createCollider(RAPIER.ColliderDesc.cuboid(SIZE/2, SIZE/2), vehicle);

let foodParticles = [];
function spawnFood() {
  while(foodParticles.length < params.foodCount) {
    foodParticles.push({
      x: (Math.random() - 0.5) * params.worldWidth,
      y: (Math.random() - 0.5) * params.worldHeight
    });
  }
}

/* ---------------- LOGIC ---------------- */

const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup",   e => keys[e.key.toLowerCase()] = false);

function update() {
  const p = vehicle.translation();
  const a = vehicle.rotation();
  const power = params.thrustPower;
  
  // 1. SCAN FOR FOOD
  targetFood = null;
  let minDist = params.sensorRange;
  foodParticles.forEach(f => {
    const d = Math.hypot(f.x - p.x, f.y - p.y);
    if (d < minDist) { minDist = d; targetFood = f; }
  });

  // 2. AI STEERING & THRUST
  let aiThrustActive = false;
  if (params.autoSteer && targetFood) {
    const angleToFood = Math.atan2(targetFood.y - p.y, targetFood.x - p.x);
    let desiredRotation = angleToFood + Math.PI/2;
    let diff = desiredRotation - a;
    
    while (diff < -Math.PI) diff += Math.PI * 2;
    while (diff > Math.PI) diff -= Math.PI * 2;

    // Apply AI Torque
    vehicle.applyTorqueImpulse(diff * params.steeringStrength, true);

    // AI Forward Thrust if Aligned (within 15 degrees)
    if (params.autoThrust && Math.abs(diff) < Math.PI / 12) {
      aiThrustActive = true;
    }
  }

  // 3. APPLY FORCES
  const forwardImpulse = { x: Math.sin(a) * power, y: -Math.cos(a) * power };
  
  if (keys["w"] || aiThrustActive) {
    vehicle.applyImpulse(forwardImpulse, true);
  }
  if (keys["a"]) {
    vehicle.applyTorqueImpulse(-0.1, true);
    vehicle.applyImpulse({ x: forwardImpulse.x * params.turnThrustMult, y: forwardImpulse.y * params.turnThrustMult }, true);
  }
  if (keys["d"]) {
    vehicle.applyTorqueImpulse(0.1, true);
    vehicle.applyImpulse({ x: forwardImpulse.x * params.turnThrustMult, y: forwardImpulse.y * params.turnThrustMult }, true);
  }

  // Update HUD status
  hud.innerText = `SCORE: ${score} | STATUS: ${aiThrustActive ? 'AI-THRUST' : (params.autoSteer ? 'AI-STEER' : 'MANUAL')}`;

  world.step();

  // 4. WRAPPING & TRAIL
  let { x, y } = vehicle.translation();
  const hw = params.worldWidth / 2;
  const hh = params.worldHeight / 2;
  
  if (params.showTrail) {
    trail.push({x, y});
    if (trail.length > params.trailLength) trail.shift();
  }

  if (x > hw) { x = -hw; trail = []; } else if (x < -hw) { x = hw; trail = []; }
  if (y > hh) { y = -hh; trail = []; } else if (y < -hh) { y = hh; trail = []; }
  vehicle.setTranslation({ x, y }, true);

  // 5. EATING LOGIC
  foodParticles = foodParticles.filter(f => {
    if (Math.hypot(f.x - x, f.y - y) < 0.8) {
      score += 10;
      return false;
    }
    return true;
  });
  spawnFood();
}

/* ---------------- DRAWING ---------------- */

function drawScene() {
  const p = vehicle.translation();
  const a = vehicle.rotation();
  const v = vehicle.linvel();

  ctx.fillStyle = "#0a0a0a";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.scale(params.zoom, params.zoom);
  ctx.translate(-p.x * SCALE, -p.y * SCALE);

  // Bounds
  ctx.strokeStyle = "#1a3a1a";
  ctx.lineWidth = 2;
  ctx.strokeRect(-params.worldWidth/2 * SCALE, -params.worldHeight/2 * SCALE, params.worldWidth * SCALE, params.worldHeight * SCALE);

  // Trail
  if (params.showTrail && trail.length > 1) {
    ctx.beginPath();
    ctx.strokeStyle = "rgba(0, 255, 0, 0.2)";
    ctx.moveTo(trail[0].x * SCALE, trail[0].y * SCALE);
    trail.forEach(t => ctx.lineTo(t.x * SCALE, t.y * SCALE));
    ctx.stroke();
  }

  // AI Sensor Line
  if (targetFood) {
    const angleToFood = Math.atan2(targetFood.y - p.y, targetFood.x - p.x);
    let diff = (angleToFood + Math.PI/2) - a;
    while (diff < -Math.PI) diff += Math.PI * 2;
    while (diff > Math.PI) diff -= Math.PI * 2;
    const isLocked = Math.abs(diff) < Math.PI / 12;

    ctx.beginPath();
    ctx.setLineDash([5, 10]);
    ctx.strokeStyle = isLocked ? "rgba(0, 255, 0, 0.6)" : "rgba(255, 255, 255, 0.3)";
    ctx.moveTo(p.x * SCALE, p.y * SCALE);
    ctx.lineTo(targetFood.x * SCALE, targetFood.y * SCALE);
    ctx.stroke();
    ctx.setLineDash([]);
    
    ctx.strokeStyle = isLocked ? "#00FF00" : "red";
    ctx.strokeRect((targetFood.x-0.25)*SCALE, (targetFood.y-0.25)*SCALE, 0.5*SCALE, 0.5*SCALE);
  }

  // Food
  ctx.fillStyle = "#FFD700";
  foodParticles.forEach(f => {
    ctx.beginPath(); ctx.arc(f.x * SCALE, f.y * SCALE, 0.15 * SCALE, 0, Math.PI*2); ctx.fill();
  });

  // Velocity Line
  if (params.showVelocity) {
    ctx.beginPath();
    ctx.strokeStyle = "#00FFFF";
    ctx.moveTo(p.x * SCALE, p.y * SCALE);
    ctx.lineTo((p.x + v.x * params.velScale) * SCALE, (p.y + v.y * params.velScale) * SCALE);
    ctx.stroke();
  }

  // Vehicle
  ctx.save();
  ctx.translate(p.x * SCALE, p.y * SCALE);
  ctx.rotate(a);
  
  if (params.showThrusters && (keys["w"] || (params.autoThrust && targetFood))) {
    ctx.fillStyle = "rgba(255, 100, 0, " + (0.5 + Math.random() * 0.5) + ")";
    ctx.beginPath();
    ctx.moveTo(-0.4*SCALE, 0.5*SCALE); ctx.lineTo(0.4*SCALE, 0.5*SCALE);
    ctx.lineTo(0, (0.5 + params.thrusterSize)*SCALE); ctx.fill();
  }

  ctx.fillStyle = "#4CAF50";
  ctx.fillRect(-SIZE*SCALE/2, -SIZE*SCALE/2, SIZE*SCALE, SIZE*SCALE);
  ctx.fillStyle = "#00FF00";
  ctx.fillRect(-2, -SIZE*SCALE/2, 4, 15);
  ctx.restore();

  ctx.restore();

  // Mini Map
  if (params.showMiniMap) {
    const ms = 180, pad = 20;
    ctx.save();
    ctx.translate(canvas.width - ms - pad, pad);
    ctx.fillStyle = "rgba(0, 40, 0, 0.6)";
    ctx.fillRect(0, 0, ms, ms);
    const sx = ms / params.worldWidth, sy = ms / params.worldHeight;
    ctx.fillStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.arc((p.x + params.worldWidth/2) * sx, (p.y + params.worldHeight/2) * sy, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

function loop() {
  update();
  drawScene();
  requestAnimationFrame(loop);
}

spawnFood();
loop();
</script>
</body>
</html>