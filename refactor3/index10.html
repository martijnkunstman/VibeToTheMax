<!DOCTYPE html>
<html>
<head>
    <title>AI Evolution - Lifespan & HUD Fix</title>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: 'Courier New', monospace; display: flex; overflow: hidden; }
        #sidebar { width: 340px; padding: 20px; border-right: 2px solid #0f0; background: #080808; z-index: 10; height: 100vh; display: flex; flex-direction: column; }
        canvas { background: #000; flex-grow: 1; }
        .stat { margin-bottom: 8px; font-size: 13px; border-left: 2px solid #0f0; padding-left: 10px; color: #fff; }
        .label { color: #0f0; font-weight: bold; margin-top: 15px; display: block; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; }
        #miniMap { background: #000; border: 1px solid #333; margin-top: 5px; flex-shrink: 0; }
        #nnCanvas { background: #050505; border: 1px solid #222; margin-top: 5px; flex-grow: 1; }
        button { background: #0f0; color: #000; border: none; padding: 10px; cursor: pointer; width: 100%; margin-top: 15px; font-weight: bold; }
        h2 { margin: 0 0 15px 0; font-size: 1.2em; border-bottom: 1px solid #333; padding-bottom: 5px; }
        #save-indicator { font-size: 10px; color: #888; margin-top: 5px; text-align: center; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>NEURAL_PILOT_V9</h2>
        <div class="stat">GENERATION: <span id="genHUD">1</span></div>
        <div class="stat">ELITE FITNESS: <span id="fitness">0</span></div>
        <div class="stat">ACTIVE UNITS: <span id="aliveCount">0</span></div>
        
        <span class="label">Radar (4000x4000)</span>
        <canvas id="miniMap" width="300" height="150"></canvas>
        
        <span class="label">Neural Architecture</span>
        <canvas id="nnCanvas" width="300" height="400"></canvas>
        
        <button onclick="resetEvolution()">Factory Reset</button>
        <div id="save-indicator">Memory: Initializing...</div>
    </div>
    <canvas id="simCanvas"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const mmCtx = document.getElementById('miniMap').getContext('2d');
const nnCtx = document.getElementById('nnCanvas').getContext('2d');

const WORLD_SIZE = 4000;
const STORAGE_KEY = 'ai_v9_lifespan_save';
const SENSOR_COUNT = 11;
const SENSOR_RANGE = 350;
const DETECTION_RADIUS = 80;

canvas.width = window.innerWidth - 340;
canvas.height = window.innerHeight;

class NeuralNetwork {
    constructor(inputs, hidden, outputs) {
        this.weights1 = Array.from({length: hidden}, () => Array(inputs).fill(0).map(() => Math.random() * 2 - 1));
        this.weights2 = Array.from({length: outputs}, () => Array(hidden).fill(0).map(() => Math.random() * 2 - 1));
        this.lastInputs = Array(inputs).fill(0);
        this.lastHidden = Array(hidden).fill(0);
        this.lastOutputs = Array(outputs).fill(0);
    }
    predict(inputs) {
        this.lastInputs = inputs;
        this.lastHidden = this.weights1.map(row => 1 / (1 + Math.exp(-row.reduce((sum, w, i) => sum + w * inputs[i], 0))));
        this.lastOutputs = this.weights2.map(row => 1 / (1 + Math.exp(-row.reduce((sum, w, i) => sum + w * this.lastHidden[i], 0))));
        return this.lastOutputs;
    }
    mutate(rate) {
        const m = (v) => Math.random() < rate ? v + (Math.random() * 0.4 - 0.2) : v;
        this.weights1 = this.weights1.map(row => row.map(m));
        this.weights2 = this.weights2.map(row => row.map(m));
    }
}

class Vehicle {
    constructor(brain = null) {
        this.brain = brain || new NeuralNetwork(SENSOR_COUNT, 8, 2);
        this.spawn();
        this.thrustL = 0;
        this.thrustR = 0;
    }
    spawn() {
        this.x = Math.random() * WORLD_SIZE;
        this.y = Math.random() * WORLD_SIZE;
        this.angle = Math.random() * Math.PI * 2;
        this.health = 100;
        this.maxHealth = 100;
        this.fitness = 0;
        this.dead = false;
        this.sensorValues = Array(SENSOR_COUNT).fill(0);
    }
    update(food, obstacles) {
        if (this.dead) return;
        if (this.x < 0) this.x = WORLD_SIZE; else if (this.x > WORLD_SIZE) this.x = 0;
        if (this.y < 0) this.y = WORLD_SIZE; else if (this.y > WORLD_SIZE) this.y = 0;

        for (let i = 0; i < SENSOR_COUNT; i++) {
            const angleOffset = -1.0 + (i / (SENSOR_COUNT - 1)) * 2.0;
            const rayAngle = this.angle + angleOffset;
            let val = 0;
            const scanX = this.x + Math.cos(rayAngle) * SENSOR_RANGE;
            const scanY = this.y + Math.sin(rayAngle) * SENSOR_RANGE;
            food.forEach(f => { if(Math.hypot(f.x - scanX, f.y - scanY) < DETECTION_RADIUS) val = 1; });
            obstacles.forEach(o => { if(Math.hypot(o.x - scanX, o.y - scanY) < DETECTION_RADIUS) val = -1; });
            this.sensorValues[i] = val;
        }

        const outputs = this.brain.predict(this.sensorValues);
        this.thrustL = outputs[0];
        this.thrustR = outputs[1];

        this.angle += (this.thrustL - this.thrustR) * 0.12;
        this.x += Math.cos(this.angle) * (this.thrustL + this.thrustR) * 3.5;
        this.y += Math.sin(this.angle) * (this.thrustL + this.thrustR) * 3.5;
        
        this.health -= 0.18; // Decay
        this.fitness += 0.1;

        food.forEach((f, i) => {
            if (Math.hypot(this.x-f.x, this.y-f.y) < 25) {
                this.health = Math.min(this.maxHealth, this.health + 40); 
                this.fitness += 150;
                food[i] = {x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE};
            }
        });
        obstacles.forEach(o => { if (Math.hypot(this.x-o.x, this.y-o.y) < 18) this.dead = true; });
        if (this.health <= 0) this.dead = true;
    }
    draw(ctx, isLeader) {
        ctx.save();
        ctx.translate(this.x, this.y);

        // Lifespan Bar
        ctx.fillStyle = "#333";
        ctx.fillRect(-15, -20, 30, 4);
        ctx.fillStyle = this.health > 30 ? "#0f0" : "#f00";
        ctx.fillRect(-15, -20, (this.health / this.maxHealth) * 30, 4);

        ctx.rotate(this.angle);
        if (this.thrustL > 0.1) {
            ctx.fillStyle = `rgba(255, 100, 0, ${this.thrustL})`;
            ctx.fillRect(-15, -10, -this.thrustL * 25, 4);
        }
        if (this.thrustR > 0.1) {
            ctx.fillStyle = `rgba(255, 100, 0, ${this.thrustR})`;
            ctx.fillRect(-15, 6, -this.thrustR * 25, 4);
        }

        for (let i = 0; i < SENSOR_COUNT; i++) {
            const angleOffset = -1.0 + (i / (SENSOR_COUNT - 1)) * 2.0;
            const v = this.sensorValues[i];
            ctx.strokeStyle = v > 0 ? '#0f0' : (v < 0 ? '#f00' : 'rgba(255,255,255,0.05)');
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angleOffset) * SENSOR_RANGE, Math.sin(angleOffset) * SENSOR_RANGE); ctx.stroke();
        }
        ctx.fillStyle = isLeader ? '#fff' : '#0ff';
        ctx.beginPath(); ctx.moveTo(18,0); ctx.lineTo(-10,-10); ctx.lineTo(-10,10); ctx.fill();
        ctx.restore();
    }
}

let vehicles = [], food = [], obstacles = [], gen = 1;
let cameraX = 0, cameraY = 0;



function init() {

    const dataStorage = '{"w1":[[0.46463746067258027,0.6649573543450882,-0.18017065002305807,1.0914054457397264,0.681933635413495,-0.6350356641017043,-0.7858983504983538,-0.24118193613541994,0.019268782395553463,0.4312809329896055,-0.40777874280233267],[-0.38028020455342826,-1.065360753922585,0.46924117377942215,-0.011808031261790364,-0.23448593628424308,-0.5755608097706009,0.3769731924888396,-0.05232414368964734,-0.04338334404033051,0.15758119562554843,0.7431232448738183],[-0.5982568127409215,0.8633300805221449,0.27597973117148816,-0.6499004390323224,-0.5756984003527807,-0.9450060482028082,0.4633146247054296,-0.3583214486593073,0.8071770978543773,0.5734511020753081,0.5990427270394671],[-0.09636973741687813,-0.24077470375624072,0.7826303270565564,-0.3449433273838617,-0.2606786449177605,-0.5505447331788181,-0.795369537168571,0.7072852964129352,-0.9350671476447714,-0.3039270895386451,-0.5446725022770804],[-0.656053312256265,0.9127795325217827,-0.658864779403807,-0.6218969010479611,-0.00683400230594694,0.3785783560378527,-0.25061476889074075,0.2759041295172277,-0.643338769349232,-0.240007666269015,0.12206996086764776],[-0.3232399673886144,-1.3365768446577848,0.3995340914248649,-0.6584258436588653,-0.8091723805408229,-0.025875372609583336,0.6744775538629652,0.32106778557054555,-1.0410567761419112,-0.18095869060653041,0.5131344896915456],[-0.6012570193487726,0.07087369937647403,-0.0015778059086742346,-0.7034833743588481,-0.5159584150599037,0.0902173320059006,-0.7014140716130025,-0.034380419379258065,0.9858554997351077,0.052171528963668334,-0.1498595165783781],[0.494653761490381,-0.8302314020569528,-0.9259594989700832,0.39254137232576897,-0.32174382223403075,0.24064481841904858,-0.2312758464824355,-1.0555182527157962,0.11983566544502539,-0.7559597124722943,0.21559536945768076]],"w2":[[-1.028054460993147,-0.8318673640744809,0.8413221381293507,-0.09138548564118287,0.3801614887520542,0.1522712389356347,0.33301383823255243,-0.12373367843932673],[-0.6536343092731904,0.36718982085637236,0.10923972650618108,-0.08248125802071149,-0.08548751367951116,-0.597345667370554,0.5876962673771269,0.08211451252736757]],"gen":24}';

    if (localStorage.getItem(STORAGE_KEY) === null) {
        localStorage.setItem(STORAGE_KEY, dataStorage);
    }

    const data = localStorage.getItem(STORAGE_KEY);


    //ai_v9_lifespan_save
    localStorage.getItem(STORAGE_KEY);


    let saved = data ? JSON.parse(data) : null;
    if (saved) gen = saved.gen || 1;
    
    document.getElementById('genHUD').innerText = gen;

    food = Array.from({length: 150}, () => ({x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE}));
    obstacles = Array.from({length: 100}, () => ({x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE}));
    
    vehicles = Array.from({length: 12}, (_, i) => {
        const b = new NeuralNetwork(SENSOR_COUNT, 8, 2);
        if (saved) {
            b.weights1 = saved.w1; b.weights2 = saved.w2;
            if (i > 0) b.mutate(0.12);
        }
        return new Vehicle(b);
    });
}

function drawUI(leader) {
    mmCtx.fillStyle = '#000'; mmCtx.fillRect(0,0,300,150);
    const sX = 300/WORLD_SIZE; const sY = 150/WORLD_SIZE;
    food.forEach(f => { mmCtx.fillStyle = '#0a0'; mmCtx.fillRect(f.x*sX, f.y*sY, 1.5, 1.5); });
    obstacles.forEach(o => { mmCtx.fillStyle = '#a00'; mmCtx.fillRect(o.x*sX, o.y*sY, 1.5, 1.5); });
    vehicles.forEach(v => { if(!v.dead) { mmCtx.fillStyle = (v===leader)?'#fff':'#0ff'; mmCtx.fillRect(v.x*sX, v.y*sY, 3, 3); }});

    nnCtx.clearRect(0,0,300,400);
    const brain = leader.brain;
    const padding = 40;
    const colX = [padding, 150, 300 - padding];

    brain.weights1.forEach((row, h) => {
        row.forEach((w, i) => {
            nnCtx.strokeStyle = w > 0 ? `rgba(0,255,0,${Math.abs(w)*0.4})` : `rgba(255,0,0,${Math.abs(w)*0.4})`;
            nnCtx.lineWidth = Math.abs(w) * 2;
            nnCtx.beginPath(); nnCtx.moveTo(colX[0], 25 + i * 34); nnCtx.lineTo(colX[1], 50 + h * 42); nnCtx.stroke();
        });
    });

    brain.weights2.forEach((row, o) => {
        row.forEach((w, h) => {
            nnCtx.strokeStyle = w > 0 ? `rgba(0,255,0,${Math.abs(w)*0.4})` : `rgba(255,0,0,${Math.abs(w)*0.4})`;
            nnCtx.lineWidth = Math.abs(w) * 2;
            nnCtx.beginPath(); nnCtx.moveTo(colX[1], 50 + h * 42); nnCtx.lineTo(colX[2], 150 + o * 100); nnCtx.stroke();
        });
    });

    const drawNode = (x, y, active) => {
        nnCtx.fillStyle = active > 0.5 ? '#0f0' : (active < -0.5 ? '#f00' : '#111');
        nnCtx.beginPath(); nnCtx.arc(x, y, 8, 0, Math.PI*2); nnCtx.fill();
        nnCtx.strokeStyle = '#fff'; nnCtx.stroke();
    };

    brain.lastInputs.forEach((v, i) => drawNode(colX[0], 25 + i * 34, v));
    brain.lastHidden.forEach((v, i) => drawNode(colX[1], 50 + i * 42, v));
    brain.lastOutputs.forEach((v, i) => drawNode(colX[2], 150 + i * 100, v));
}

function loop() {
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width, canvas.height);
    let alive = vehicles.filter(v => !v.dead);
    let leader = alive[0] || vehicles[0];

    cameraX += (leader.x - canvas.width/2 - cameraX) * 0.05;
    cameraY += (leader.y - canvas.height/2 - cameraY) * 0.05;

    ctx.save(); ctx.translate(-cameraX, -cameraY);
    food.forEach(f => { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(f.x, f.y, 8, 0, 7); ctx.fill(); });
    obstacles.forEach(o => { ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(o.x, o.y, 10, 0, 7); ctx.fill(); });
    alive.forEach(v => { v.update(food, obstacles); v.draw(ctx, v === leader); });
    ctx.restore();

    drawUI(leader);
    document.getElementById('aliveCount').innerText = alive.length;

    if (alive.length === 0) {
        let best = vehicles.sort((a,b) => b.fitness - a.fitness)[0];
        gen++; // Increment before saving
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
            w1: best.brain.weights1, 
            w2: best.brain.weights2,
            gen: gen
        }));
        document.getElementById('fitness').innerText = Math.round(best.fitness);
        document.getElementById('save-indicator').innerText = `Sync: Gen ${gen} Uploaded`;
        init();
    }
    requestAnimationFrame(loop);
}

function resetEvolution() { localStorage.removeItem(STORAGE_KEY); location.reload(); }
init();
loop();
</script>
</body>
</html>