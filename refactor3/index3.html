<!DOCTYPE html>
<html>
<head>
    <title>AI Evolution - Persistent Memory</title>
    <style>
        body { margin: 0; background: #0a0a0a; color: #0f0; font-family: 'Segoe UI', sans-serif; display: flex; overflow: hidden; }
        #sidebar { width: 320px; padding: 20px; border-right: 2px solid #0f0; background: #000; box-shadow: 5px 0 15px rgba(0,255,0,0.2); display: flex; flex-direction: column; }
        canvas { background: radial-gradient(circle, #111 0%, #000 100%); flex-grow: 1; }
        .stat { margin-bottom: 8px; font-size: 13px; border-left: 3px solid #0f0; padding-left: 10px; }
        .mini-map { border: 1px solid #333; margin-top: 10px; background: #000; }
        button { background: #0f0; color: #000; border: none; padding: 10px; cursor: pointer; font-weight: bold; margin-top: 10px; text-transform: uppercase; }
        button:hover { background: #fff; }
        h2 { text-transform: uppercase; letter-spacing: 2px; margin-bottom: 20px; font-size: 1.2em; }
        #memory-status { font-size: 10px; color: #888; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>Neural Link v2.0</h2>
        <div class="stat">GEN: <span id="gen">1</span></div>
        <div class="stat">ELITE FITNESS: <span id="fitness">0</span></div>
        <div class="stat">ALIVE: <span id="aliveCount">10</span></div>
        <canvas id="nnCanvas" width="280" height="180"></canvas>
        <div class="stat">RADAR</div>
        <canvas id="miniMap" class="mini-map" width="280" height="150"></canvas>
        
        <button onclick="resetEvolution()">Hard Restart</button>
        <div id="memory-status">Memory: Checking...</div>
    </div>
    <canvas id="simCanvas"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const nnCtx = document.getElementById('nnCanvas').getContext('2d');
const mmCtx = document.getElementById('miniMap').getContext('2d');

canvas.width = window.innerWidth - 320;
canvas.height = window.innerHeight;

// --- Persistence Keys ---
const STORAGE_KEY = 'ai_vehicle_champion';

class NeuralNetwork {
    constructor(inputs, hidden, outputs) {
        this.weights1 = Array.from({length: hidden}, () => Array(inputs).fill(0).map(() => Math.random() * 2 - 1));
        this.weights2 = Array.from({length: outputs}, () => Array(hidden).fill(0).map(() => Math.random() * 2 - 1));
        this.lastInputs = [0,0,0,0,0];
        this.lastHidden = [0,0,0,0,0,0];
    }

    predict(inputs) {
        this.lastInputs = inputs;
        this.lastHidden = this.weights1.map(row => this.sigmoid(row.reduce((sum, w, i) => sum + w * inputs[i], 0)));
        return this.weights2.map(row => this.sigmoid(row.reduce((sum, w, i) => sum + w * this.lastHidden[i], 0)));
    }

    sigmoid(x) { return 1 / (1 + Math.exp(-x)); }

    mutate(rate) {
        const m = (v) => Math.random() < rate ? v + (Math.random() * 0.4 - 0.2) : v;
        this.weights1 = this.weights1.map(row => row.map(m));
        this.weights2 = this.weights2.map(row => row.map(m));
    }
}

class Vehicle {
    constructor(brain = null) {
        this.brain = brain || new NeuralNetwork(5, 6, 2);
        this.spawn();
    }

    spawn() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.angle = Math.random() * Math.PI * 2;
        this.health = 100;
        this.fitness = 0;
        this.dead = false;
        this.sensors = [0,0,0,0,0];
    }

    update() {
        if (this.dead) return;
        const sensorAngles = [-0.5, -0.25, 0, 0.25, 0.5];
        this.sensors = sensorAngles.map(off => {
            let reading = 0;
            const lx = this.x + Math.cos(this.angle + off) * 80;
            const ly = this.y + Math.sin(this.angle + off) * 80;
            food.forEach(f => { if(Math.hypot(f.x-lx, f.y-ly) < 25) reading = 1; });
            obstacles.forEach(o => { if(Math.hypot(o.x-lx, o.y-ly) < 25) reading = -1; });
            return reading;
        });

        const [l, r] = this.brain.predict(this.sensors);
        this.angle += (l - r) * 0.15;
        this.x += Math.cos(this.angle) * (l + r) * 3;
        this.y += Math.sin(this.angle) * (l + r) * 3;

        this.health -= 0.15;
        this.fitness += 0.1;

        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.die();

        food.forEach((f, i) => {
            if (Math.hypot(this.x-f.x, this.y-f.y) < 15) {
                this.health += 50; this.fitness += 100;
                food[i] = {x: Math.random()*canvas.width, y: Math.random()*canvas.height};
            }
        });

        obstacles.forEach(o => {
            if (Math.hypot(this.x-o.x, this.y-o.y) < 15) this.die();
        });

        if (this.health <= 0) this.die();
    }

    die() { this.dead = true; }

    draw() {
        if (this.dead) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = '#0ff';
        ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-8,-6); ctx.lineTo(-8,6); ctx.fill();
        ctx.restore();
    }
}

// --- Environment ---
let vehicles = [];
let food = Array.from({length: 25}, () => ({x: Math.random()*canvas.width, y: Math.random()*canvas.height}));
let obstacles = Array.from({length: 15}, () => ({x: Math.random()*canvas.width, y: Math.random()*canvas.height}));
let gen = 1;

function saveBrain(brain) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
        w1: brain.weights1,
        w2: brain.weights2,
        gen: gen
    }));
    document.getElementById('memory-status').innerText = "Memory: Saved Gen " + gen;
}

function loadBrain() {
    const data = localStorage.getItem(STORAGE_KEY);
    if (data) {
        const parsed = JSON.parse(data);
        const brain = new NeuralNetwork(5, 6, 2);
        brain.weights1 = parsed.w1;
        brain.weights2 = parsed.w2;
        gen = parsed.gen;
        document.getElementById('memory-status').innerText = "Memory: Loaded Gen " + gen;
        return brain;
    }
    document.getElementById('memory-status').innerText = "Memory: No saved data.";
    return null;
}

function resetEvolution() {
    localStorage.removeItem(STORAGE_KEY);
    location.reload();
}

function init() {
    const savedBrain = loadBrain();
    vehicles = Array.from({length: 12}, () => {
        if (savedBrain) {
            const b = new NeuralNetwork(5, 6, 2);
            b.weights1 = JSON.parse(JSON.stringify(savedBrain.weights1));
            b.weights2 = JSON.parse(JSON.stringify(savedBrain.weights2));
            b.mutate(0.1);
            return new Vehicle(b);
        }
        return new Vehicle();
    });
}

function loop() {
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0,0,canvas.width, canvas.height);

    food.forEach(f => { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(f.x, f.y, 5, 0, 7); ctx.fill(); });
    obstacles.forEach(o => { ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(o.x, o.y, 7, 0, 7); ctx.fill(); });

    let alive = vehicles.filter(v => !v.dead);
    document.getElementById('aliveCount').innerText = alive.length;
    alive.forEach(v => { v.update(); v.draw(); });

    // UI Updates
    if (alive.length > 0) {
        nnCtx.clearRect(0,0,280,180);
        alive[0].brain.lastInputs.forEach((v, i) => {
            nnCtx.fillStyle = v > 0 ? '#0f0' : (v < 0 ? '#f00' : '#444');
            nnCtx.beginPath(); nnCtx.arc(40, 30+i*30, 8, 0, 7); nnCtx.fill();
        });
    }

    if (alive.length === 0) {
        let best = vehicles.sort((a,b) => b.fitness - a.fitness)[0];
        document.getElementById('fitness').innerText = Math.round(best.fitness);
        saveBrain(best.brain);
        
        vehicles = vehicles.map((_, i) => {
            const b = new NeuralNetwork(5, 6, 2);
            b.weights1 = JSON.parse(JSON.stringify(best.brain.weights1));
            b.weights2 = JSON.parse(JSON.stringify(best.brain.weights2));
            if (i > 0) b.mutate(0.1);
            return new Vehicle(b);
        });
        gen++;
        document.getElementById('gen').innerText = gen;
    }
    requestAnimationFrame(loop);
}

init();
loop();
</script>
</body>
</html>