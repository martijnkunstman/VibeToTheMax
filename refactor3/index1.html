<!DOCTYPE html>
<html>
<head>
    <title>AI Thruster Vehicle</title>
    <style>
        body { margin: 0; background: #222; color: white; font-family: sans-serif; display: flex; }
        canvas { background: #000; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #controls { padding: 20px; width: 300px; }
        .stat { margin-bottom: 10px; font-size: 14px; }
    </style>
</head>
<body>
    <canvas id="simCanvas"></canvas>
    <div id="controls">
        <h2>AI Simulation</h2>
        <div class="stat">Generation: <span id="gen">1</span></div>
        <div class="stat">Best Fitness: <span id="fitness">0</span></div>
        <canvas id="nnCanvas" width="280" height="200"></canvas>
        <p><small>Green = Food (+)<br>Red = Obstacle (-)<br>Vehicle uses 2 thrusters to steer.</small></p>
    </div>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const nnCanvas = document.getElementById('nnCanvas');
const nnCtx = nnCanvas.getContext('2d');

canvas.width = window.innerWidth - 320;
canvas.height = window.innerHeight;

// --- Neural Network Helper ---
class NeuralNetwork {
    constructor(inputNodes, hiddenNodes, outputNodes) {
        this.weights1 = Array.from({length: hiddenNodes}, () => Array(inputNodes).fill(0).map(() => Math.random() * 2 - 1));
        this.weights2 = Array.from({length: outputNodes}, () => Array(hiddenNodes).fill(0).map(() => Math.random() * 2 - 1));
    }

    predict(inputs) {
        let hidden = this.weights1.map(nodeWeights => 
            this.activate(nodeWeights.reduce((sum, w, i) => sum + w * inputs[i], 0)));
        return this.weights2.map(nodeWeights => 
            this.activate(nodeWeights.reduce((sum, w, i) => sum + w * hidden[i], 0)));
    }

    activate(x) { return 1 / (1 + Math.exp(-x)); } // Sigmoid

    mutate(rate) {
        const mutateArr = (arr) => arr.map(row => row.map(v => Math.random() < rate ? v + (Math.random() * 2 - 1) * 0.5 : v));
        this.weights1 = mutateArr(this.weights1);
        this.weights2 = mutateArr(this.weights2);
    }
}

// --- Vehicle Entity ---
class Vehicle {
    constructor(brain) {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.angle = Math.random() * Math.PI * 2;
        this.health = 1;
        this.fitness = 0;
        this.brain = brain || new NeuralNetwork(5, 6, 2);
        this.sensors = [0, 0, 0, 0, 0];
    }

    update(food, obstacles) {
        // 1. Update Sensors (detect distance to food/obstacles)
        this.sensors = [-0.4, -0.2, 0, 0.2, 0.4].map(offset => {
            let dist = 100;
            let rayAngle = this.angle + offset;
            // Simplified sensing: distance to nearest object in field of view
            [...food, ...obstacles].forEach(obj => {
                let dx = obj.x - this.x;
                let dy = obj.y - this.y;
                let d = Math.sqrt(dx*dx + dy*dy);
                if (d < 150) {
                    let angleToObj = Math.atan2(dy, dx);
                    if (Math.abs(angleToObj - rayAngle) < 0.1) dist = Math.min(dist, d);
                }
            });
            return 1 - (dist / 150); // Normalize 0 to 1
        });

        // 2. Brain Decision
        let [leftThruster, rightThruster] = this.brain.predict(this.sensors);
        
        // 3. Physics (Thruster differential steering)
        let speed = (leftThruster + rightThruster) * 2;
        this.angle += (leftThruster - rightThruster) * 0.15;
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;

        // Bound check
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.health = 0;

        // Scoring
        this.fitness += 0.1; 
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = 'cyan';
        ctx.fillRect(-10, -5, 20, 10);
        // Draw Thrusters
        ctx.fillStyle = 'orange';
        ctx.fillRect(-12, -7, 4, 4); // Left
        ctx.fillRect(-12, 3, 4, 4);  // Right
        ctx.restore();
    }
}

// --- World Setup & Loop ---
let vehicles = Array.from({length: 10}, () => new Vehicle());
let food = Array.from({length: 15}, () => ({x: Math.random()*canvas.width, y: Math.random()*canvas.height}));
let obstacles = Array.from({length: 10}, () => ({x: Math.random()*canvas.width, y: Math.random()*canvas.height}));
let genCount = 1;

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw Environment
    food.forEach(f => { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(f.x, f.y, 5, 0, Math.PI*2); ctx.fill(); });
    obstacles.forEach(o => { ctx.fillStyle = '#f00'; ctx.fillRect(o.x-8, o.y-8, 16, 16); });

    vehicles.forEach(v => {
        if (v.health > 0) {
            v.update(food, obstacles);
            v.draw();
        }
    });

    // Simple reset if all die or time passes
    if (vehicles.every(v => v.health <= 0)) {
        let best = vehicles.sort((a,b) => b.fitness - a.fitness)[0];
        document.getElementById('fitness').innerText = Math.round(best.fitness);
        vehicles = Array.from({length: 10}, () => {
            let newBrain = JSON.parse(JSON.stringify(best.brain)); // Clone
            Object.setPrototypeOf(newBrain, NeuralNetwork.prototype);
            newBrain.mutate(0.1);
            return new Vehicle(newBrain);
        });
        genCount++;
        document.getElementById('gen').innerText = genCount;
    }

    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>